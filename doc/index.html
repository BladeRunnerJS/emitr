<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Home</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Home</h1>

    



    


    <h3> </h3>










    




    <section>
        <article><hr>
<p>layout: main
permalink: /index.html</p>
<h2>title: emitr</h2><script type="text/javascript" src="target/single/emitr.js"></script>

<h1>emitr</h1><p>A simple emitter for node and the browser.</p>
<p><a href="https://travis-ci.org/BladeRunnerJS/emitr"><img src="https://travis-ci.org/BladeRunnerJS/emitr.png" alt="Build Status"></a></p>
<ul>
<li>This document is available nicely formatted <a href="http://BladeRunnerJS.github.io/emitr">here</a>.</li>
<li>Tests are <a href="http://BladeRunnerJS.github.io/emitr/spec">here</a>.</li>
<li>Source code is <a href="https://github.com/BladeRunnerJS/emitr">here</a>.</li>
<li>JSDoc for the Emitter mixin is <a href="http://BladeRunnerJS.github.io/emitr/doc/Emitter.html">here</a>.</li>
</ul>
<p>The rendered form of this document includes the Emitter script so you can open a console and try it
immediately.</p>
<p>My two main inspirations in making this implementation were the events in <a href="http://backbonejs.org/#Events">backbone</a>,
and the EventEmitter in <a href="http://nodejs.org/docs/latest/api/all.html#all_class_events_eventemitter">node</a>.</p>
<p>If we hadn't required the ability to pass 'context' into <code>on</code> and <code>off</code>, we probably would have gone with
<a href="http://robertwhurst.github.io/LucidJS/">LucidJS</a>.  Not leaking memory is difficult enough when
building large applications; forcing people to keep extra objects around just so they can clean up after
themselves is ugly enough that it discourages people from doing something important.</p>
<p>While I haven't come across this exact combination of focussed microlibrary combined with context,
the only unusual feature of this Emitter (and deliberately so) is that it allows you to listen to and
dispatch objects rather than just strings.  Related to this is type based events, which I describe
later.</p>
<h2>Getting It</h2><p>In node</p>
<pre class="prettyprint source"><code>$ npm install emitr --save</code></pre><p>To get the source (you'll want to npm install it afterwards)</p>
<pre class="prettyprint source"><code>$ git clone https://github.com/BladeRunnerJS/emitr.git</code></pre><p>With Bower</p>
<pre class="prettyprint source"><code>$ bower install emitr</code></pre><p>In the browser (better to take a copy of the file and serve it from within your app)</p>
<pre class="prettyprint source"><code>&lt;script type=&quot;text/javascript&quot; src=&quot;http://bladerunnerjs.github.io/emitr/target/single/emitr.js&quot;>&lt;/script></code></pre><p>With require.js (again, better to take a copy and serve it within your app)</p>
<pre class="prettyprint source"><code>require([&quot;http://bladerunnerjs.github.io/emitr/target/single/emitr.js&quot;], function(emitr) {
    // do your thing with emitr
});</code></pre><h2>Making an Emitter</h2><p>While you can directly create a new Emitter (with <code>new emitr()</code>, or use standard prototypical
inheritance to inherit from it, usually you will want to mix the Emitter
methods in to your own classes or objects.</p>
<pre class="prettyprint source lang-javascript"><code>
    function MyEmitter() {};
    emitr.mixInto(MyEmitter);

    var emitter = new MyEmitter();</code></pre><h2>Standard Emitter Features</h2><p>The big three methods are provided:</p>
<p>on:</p>
<pre class="prettyprint source lang-javascript"><code>
    // Basic example:

    emitter.on('some-event', function() {
        // By default, 'this' is set to emitter inside here.
        // you can change that by providing a context argument.
    });

    // Example using context:

    function MyObject() {}
    MyObject.prototype.onBoom = function() {
        // in this example, 'this' is set to 'obj'.
    };

    var obj = new MyObject();
    emitter.on('end-of-the-world', obj.onBoom, obj);</code></pre><p>The poorly (but commonly) named off:</p>
<pre class="prettyprint source lang-javascript"><code>
    // clears all listeners registered on emitter.
    emitter.off();

    // clears all listeners for 'some-event'.
    emitter.off('some-event');

    // removes the listener added with
    //    emitter.on('some-event', callback);
    emitter.off('some-event', callback);

    // removes the listener added with
    //    emitter.on('some-event', callback, context);
    emitter.off('some-event', callback, context);

    // removes all listeners registered with a context of context.
    emitter.off(null, null, context);
    // or
    emitter.clearListeners(context);</code></pre><p>trigger (sometimes called emit or fire or notify):</p>
<pre class="prettyprint source lang-javascript"><code>
    // All listeners registered for the 'end-of-the-world' event
    // will get called with alienSpacecraft as their first argument.
    emitters.trigger('end-of-the-world', alienSpacecraft);</code></pre><p>once is another function that is commonly provided by Emitters:</p>
<pre class="prettyprint source lang-javascript"><code>
    // Once behaves similarly to .on, but the listener is only
    // ever called once.
    emitter.once('some-event', function() {
        // this function will only be called once.
    });

    emitter.trigger('some-event');
    emitter.trigger('some-event');</code></pre><h2>Extra Features</h2><p>This Emitter provides two extra features.</p>
<h3>MetaEvents</h3><p>The emitter will also trigger special events that you can listen to in certain
circumstances. The event emitter in node does a similar thing, firing <code>newListener</code>
and <code>removeListener</code> events at the appropriate time.</p>
<p>There are three meta events which are:</p>
<ul>
<li><code>emitr.meta.AddListenerEvent</code>, triggered when a listener is added.</li>
<li><code>emitr.meta.RemoveListenerEvent</code>, triggered when a listener is removed.</li>
<li><code>emitr.meta.DeadEvent</code>, triggered when an event is fired but no listeners receive it.</li>
</ul>
<pre class="prettyprint source lang-javascript"><code>
    // In this example, I use an AddListenerEvent metaevent to
    // create 'sticky' events behaviour for the ready event.

    function Document() {
        this.isReady = false;

        this.on(Emitter.meta.AddListenerEvent, function(addEvent) {
            if (this.isReady) {
                addEvent.listener.call(addEvent.context);
            }
        }, this);
    }
    Emitter.mixInto(Document);
    Document.prototype.makeReady = function() {
        this.isReady = true;
        this.trigger('ready');
    };

    var doc = new Document();

    doc.makeReady();

    // Even though makeReady was called before this 'on',
    // the listener will still be called.

    doc.on('ready', function() {
        console.log('ready now');
    });</code></pre><h3>Type Based Events</h3><p>The Events themselves in normal usage are usually string identifiers and then a list of
arguments, almost like an algebraic data type - a tag and then a tuple of data items.  In an
object language like javascript, it seems more natural to dispatch event objects instead and
listen for them based on their type.</p>
<pre class="prettyprint source lang-javascript"><code>
    function MouseEvent(x, y) {
        this.x = x;
        this.y = y;
    }

    emitter.on(MouseEvent, function(event) {
        // in here, event is the instance of MouseEvent that
        // we trigger the emitter with.
    });

    emitter.trigger(new MouseEvent(100, 99));</code></pre><p>It obeys the Liskov Substitution Principle, so a listener will also get notified of
events that are subclasses of the event type it is registered for.</p>
<pre class="prettyprint source lang-javascript"><code>
    function ClickEvent(button, x, y) {
        MouseEvent.call(this, x, y);
        this.button = button;
    }

    ClickEvent.prototype = Object.create(MouseEvent.prototype);

    emitter.on(MouseEvent, function(event) {
        // in here, event is the instance of ClickEvent that
        // we trigger the emitter with.
    });

    emitter.trigger(new ClickEvent(&quot;right&quot;, 101, 100));</code></pre></article>
    </section>






</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Emitter.html">Emitter</a></li><li><a href="Emitter.Event.html">Event</a></li><li><a href="Emitter.meta.AddListenerEvent.html">AddListenerEvent</a></li><li><a href="Emitter.meta.DeadEvent.html">DeadEvent</a></li><li><a href="Emitter.meta.ListenerEvent.html">ListenerEvent</a></li><li><a href="Emitter.meta.MetaEvent.html">MetaEvent</a></li><li><a href="Emitter.meta.RemoveListenerEvent.html">RemoveListenerEvent</a></li></ul><h3>Namespaces</h3><ul><li><a href="Emitter.meta.html">meta</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.0-dev</a> on Wed Jul 29 2015 10:45:48 GMT+0100 (BST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>